# Test handling

To ensure proper software quality there exist several commands. Since this description is part of a sub directory all commands are related to the base directory. Every test should work correctly before committing into git repository!

## Code Beautify
The basic tool for beautifying is <code>astyle</code>. Simply execute
```bash
make astyle
```

## Complete build
To ensure a build will completely succeed start a clean full build:
```bash
make clean distclean
qmake -r
make
```

You can add the <tt>-j</tt> parameter according to your number of CPU cores. This should work since all included Qt projects have correctly set dependencies.

**Note:** There should be no compiler errors nor compiler warnings! Yes, it is possible to write C++ warning free code! If I say no compiler warnings, then I mean no compiler warnings.

## CppCheck
The <code>cppcheck</code> static code analysis tool analyses the source code. Execute:
```bash
make cppcheck
```

Please check the *cppcheck.xml* file for any found problems.

## Doxygen
By simply executing the following command the API documentation will be generated into the subdirectory *api-doc* using the <code>doxygen</code> tool:
```bash
make doxygen
```
Verify that all parameters are correctly named inside the output. Follow the warnings generated by Doxygen.

## Unit Tests
It make sense to combine a unit test with valgrind memory leak detection. So make a clean full build before running
```bash
make valgrind
```
Please verify file *valgrind.xml* if there was found a memory leak. A normal run would output:
<pre>
sagittarius(~/C-Sources/ReadMrw) 6> make valgrind
valgrind --tool=memcheck --leak-check=full --show-reachable=no --undef-value-errors=no --track-origins=no --child-silent-after-fork=no --trace-children=no --gen-suppressions=no --xml=yes --xml-file=valgrind.xml test/MRW-Test
out!
2023/02/05 12:28:28.798 D - All tests OK!
</pre>

If the build is not OK, you should check the *qtest* XML result files for failed test cases.

## Statechart Tests
It is also possible to test the internal statecharts. The C++ code is generated from the *SCTUnit* files. Start the SCT Unit Tests by executing
```bash
make sct-unit
```

**Note:** When you modify the statecharts please execute target <code>make astyle</code> before committing into git repository!


## Code Coverage with gcov/lcov
You can use the <code>gcov/lcov</code> tools to measure the code coverage of the software. First prepare the code for collecting the coverage data:
```bash
make clean distclean
qmake -r CONFIG+=gcov
make
```

After successfully building the instrumented code execute all software you want for collecting coverage data. Namely run all unit test as described above:
```bash
make sct-unit valgrind
```

This takes some more time because the instrumented code need time for reporting the data. So you should be careful when testing time critical code. After comleting the executing you can prepare the coverage report by executing:
```bash
make lcov
```

After that there will be HTML reports in subdirectory *lcov-out*.

## Running all together
You can also execute all tests together. Execute:
```bash
make astyle clean distclean
qmake -r CONFIG+=gcov
make
make cppcheck sct-unit valgrind doxygen lcov
```
Execute <code>make astyle</code> before cleaning to ensure successful compiling of beautified code.

Have fun!
