//
//  SPDX-License-Identifier: MIT
//  SPDX-FileCopyrightText: Copyright (C) 2022 Steffen A. Mork
//

testclass Section for statechart mrw.^statechart.SectionStatechart
{
	operation failState()
	{
		assert active (mrw.^statechart.SectionStatechart.main_region.Failed)
		assert called fail
		assert stop
	}

	operation initing()
	{
		assert active (mrw.^statechart.SectionStatechart.main_region.Init)
		assert active (mrw.^statechart.SectionStatechart.main_region.Init.Init_Process.Requesting)
		assert active (mrw.^statechart.SectionStatechart.main_region.Init.Init_Process.Requesting.relais.Relay)
		assert active (mrw.^statechart.SectionStatechart.main_region.Init.Init_Process.Requesting.state.Occupation)
		assert entered
		assert called inc
	}

	operation unlocked()
	{
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Unlocked)
		assert called free
		assert called lock
	}

	@Test
	operation waitForStart()
	{
		enter
		assert is_active
		assert active (mrw.^statechart.SectionStatechart.main_region.Wait_for_Start)
	}

	@Test
	operation initial()
	{
		// Given
		waitForStart()

		// When
		raise start

		// Then
		initing()
	}

	@Test
	operation failAfterStart()
	{
		// Given
		initial()

		// When
		raise failed

		// Then
		failState()
	}

	@Test
	operation timeoutAfterStart()
	{
		// Given
		initial()

		// When
		proceed timeout ms

		// Then
		failState()
	}

	@Test
	operation operational()
	{
		// Given
		initial()

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Init.Init_Process.Requesting.relais.Wait)
		assert active (mrw.^statechart.SectionStatechart.main_region.Init.Init_Process.Requesting.state.Occupation)

		// When
		raise stateResponse : false

		// Then
		unlocked()
		assert called dec
	}

	@Test
	operation restart()
	{
		// Given
		operational()

		// When
		raise start

		// Then
		initing()
	}

	@Test
	operation clearing()
	{
		// Given
		failAfterStart()

		// When
		raise clear

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Wait_for_Start)

		// When
		raise start

		// Then
		initing()
	}

	@Test
	operation enabled()
	{
		// Given
		operational()

		// When
		raise enable : true

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Enabling)
		assert called dec
		assert called pending
		assert called on
	}

	@Test
	operation disabled()
	{
		// Given
		operational()

		// When
		raise enable : false

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Disabled)
	}

	@Test
	operation locked()
	{
		// Given
		enabled()

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Enabled)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Occupation.Free)
		assert called dec
		assert !occupied
	}

	@Test
	operation sectionFree()
	{
		// Given
		operational()
		occupied = false

		// When
		raise enable : true

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Enabling)

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Occupation.Free)
	}

	@Test
	operation sectionOccupied()
	{
		// Given
		operational()
		occupied = true

		// When
		raise enable : true

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Enabling)

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Occupation.Occupied)
	}

	@Test
	operation failAfterEnable()
	{
		// Given
		enabled()

		// When
		raise failed
		assert active (mrw.^statechart.SectionStatechart.main_region.Failed)
		assert called fail
	}

	@Test
	operation timeoutAfterEnable()
	{
		// Given
		enabled()

		// When
		proceed timeout ms

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Failed)
		assert called fail
	}

	@Test
	operation disableAfterEnabled()
	{
		// Given
		locked()

		// When
		raise disable

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting.Relais_processing.Disabling)
		assert called inc
		assert called off
	}

	@Test
	operation disableAfterDisabled()
	{
		// Given
		disabled()

		// When
		raise disable

		// Then
		assert called free
		assert called lock
		assert called dec
	}

	@Test
	operation unlock()
	{
		// Given
		disableAfterEnabled()

		// When
		raise relaisResponse

		// Then
		unlocked()
		assert called dec
	}

	@Test
	operation failAfterDisable()
	{
		// Given
		disableAfterEnabled()

		// When
		raise failed
		failState()
	}

	@Test
	operation timeAfterDisable()
	{
		// Given
		disableAfterEnabled()

		// When
		proceed timeout ms

		// Then
		failState()
	}

	@Test
	operation leave()
	{
		// Given
		sectionFree()
		auto_off = true

		// When
		raise stateResponse : true

		// Then
		assert occupied
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Enabled)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Occupation.Occupied)
		assert entered

		// When
		raise stateResponse : false

		// Then
		assert !occupied
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting.Relais_processing.Left)
		assert called inc
		assert called off
		assert leaving
	}

	@Test
	operation stay()
	{
		// Given
		locked()
		auto_off = false

		// When
		raise stateResponse : false

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Enabled)
	}

	@Test
	operation autoUnlock()
	{
		// Given
		leave()
		auto_unlock = true

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Unlocked)
		assert called dec
		assert left
	}

	@Test
	operation passedState()
	{
		// Given
		leave()
		auto_unlock = false

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Passed)
		assert called dec
		assert called passed
		assert left
		assert tryUnblock
	}

	@Test
	operation disableAfterPassed()
	{
		// Given
		passedState()

		// When
		raise disable

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Unlocked)
		assert called free
		assert called lock
	}

	@Test
	operation enablingAfterDisabled()
	{
		// Given
		disabled

		// When
		raise enable : true

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Waiting.Relais_processing.Enabling)
		assert called inc
		assert called on
	}

	@Test
	operation enabledAfterDisabled()
	{
		// Given
		enablingAfterDisabled

		// When
		raise relaisResponse

		// Then
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked)
		assert active (mrw.^statechart.SectionStatechart.main_region.Operating.Processing.Locked.Route_active.Enabled)
		assert called dec
	}
}
